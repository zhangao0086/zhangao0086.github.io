---
layout: post
title: "ARTS #10"
date: 2019-08-07 05:50:10
disable_excerpt: true
categories: [ARTS]
article_type: 1
---


## Algorithm

本周选择的算法题是：[Longest Palindromic Substring](<https://leetcode.com/problems/longest-palindromic-substring/>)（最长回文子串）

规则如下：

Given a string **s**, find the longest palindromic substring in **s**. You may assume that the maximum length of **s** is 1000.

**Example 1:**

```
Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.
```

**Example 2:**

```
Input: "cbbd"
Output: "bb"
```

### Solution

我实现的方案：

Runtime：88 ms，快过 96.25%。

Memory：13.6 MB，低于 23.68%。

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        filled = '#' + '#'.join(s) + '#'
        filled_length = len(filled)

        max_right = 0
        max_right_index = 0

        max_index = 0
        nums = [0] * filled_length

        for index in range(0, filled_length):
            skip = False

            if index < max_right:
                length = nums[2 * max_right_index - index]
                if length + index > max_right:
                    nums[index] = max_right - index
                else:
                    nums[index] = length
                    skip = length + index < max_right

            if not skip:
                while index - nums[index] - 1 >= 0 and index + nums[index] + 1 < filled_length:
                    if filled[index - nums[index] - 1] != filled[index + nums[index] + 1]:
                        break

                    nums[index] += 1

                max_right = index + nums[index]
                max_right_index = index

            max_index = max_index if nums[max_index] >= nums[index] else index

        low = (max_index - nums[max_index]) // 2
        high = (max_index + nums[max_index]) // 2
        return s[low:high]
```


## Review

[Achieving concurrency in Go](https://medium.com/rungo/achieving-concurrency-in-go-3f84cbf870ca)<br/>详细描述了并发和并行的区别，还着重比较了 Thread 和 Goroutine 的差异：

```
{% gist 1a357a725113e1c1cdf174a537287afd threasVsGoroutines.md %}
```

## Tip

### Jekyll

`Jekyll` 的 `post_url` tag 能为指定的 post 生成正确的 link，这样就不用硬写死了：

```
[传送门](/software/2019/08/03/The-most-important-skill-a-programmer-can-learn.html)
=>
{% raw %}[传送门]({% post_url 2019-08-03-The most important skill a programmer can learn %}){% endraw %}
```

#### JavaScript

`Array.from(iterable or arrayLike, ?mapFn, ?thisArg)` 这个函数很有意思，`iterable` 可以接收 arrayLike，这意味着只需要提供一个有 length 的任意对象，就能快速创建一个固定长度的数组，比如：

```javascript
Array.from({ length: 5 })
// (5) [undefined, undefined, undefined, undefined, undefined]

Array.from({ length: 5 }).forEach((v, i) => console.log(i) )
/*
0
1
2
3
4
*/
```

第三个参数是一个 this 指针，用于在 mapFn 里访问 *this*：

```javascript
Array.from({ length: 5 }, function(x) {
  console.log(this); // String {"This is a test"}
  return x;
}, "This is a test");
```

### Python

Python 变量都是 Block 作用域，分为三种：`global`、`local`、`nonlocal`。

- 未定义 `local` 变量时将使用 `global` 变量
- 不能同时使用同名的 `local`、`global` 变量，需要显式指定以避免含糊不清的语义
- 使用 `nonlocal` 时一定要确保能在外围作用域里找到变量，只能用于在嵌套方法中引用外围变量
- `global` 引用不到时，会定义该变量

#### 反例一

```python
def f(): 
	print(s) # UnboundLocalError: local variable 's' referenced before assignment
	s = "I love London!"
	print(s)

s = "I love Paris!"
f()

# 第二行的 s 试图在定义本地变量前访问；如果去掉第三行赋值语句，s 将使用 global 变量
```

#### 反例二

```python
def f():
    s = "I am globally not known"
    print(s) 

f()
print(s) # name 's' is not defined

# 不能访问出了作用域的本地变量 s
```

#### 反例三

```python
def f():
    nonlocal x # no binding for nonlocal 'x' found
    print(x)
    
x = 3
f()

# x 是 global 变量，不能通过 nonlocal 引用
```

#### 反例四

```python
def f():
    def g():
        nonlocal x # no binding for nonlocal 'x' found
        x = 43
    print("Before calling g: " + str(x))
    print("Calling g now:")
    g()
    print("After calling g: " + str(x))
    
x = 3
f()
print("x in main: " + str(x))

# 外围方法 f 中未定义 local 变量 x
```

更多论述及例子参见：[Global, Local and nonlocal Variables](https://www.python-course.eu/python3_global_vs_local_variables.php)

## Share

最长回文子串是一个很经典的问题，这周刚好随机到了，我想就趁此机会多记录些关于这个算法背后的设计推导。

放到这周的 Share 里，[传送门]({% post_url 2019-08-07-Manacher %})
