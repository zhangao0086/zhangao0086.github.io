---
layout: post
title: 'linux下 java JNI调用C语言动态链接库'
date: 2011-05-04 20:13:00 +0800
categories: [Java]
csdn_read_num: 6097
article_type: 2
---


<p>今天花了至少3个小时跑这个java调c的动态链接库的Hello，native world的程序。<br />把所有犯的错误和要点总结一下!<br />1 java 中 c语言函数的声明<br />&nbsp;&nbsp;&nbsp; public native static void greeting(); //就像是接口声明一样，不过有native!<br />2 编译 javac HelloNative.java ,然后使用 javah<br /><span style="color: #ff0000;">javah HelloNative会自动产生c的头文件HelloNative.h</span><br />3 生成的头文件 的 第一句子为<br />&nbsp; #include <br />&nbsp; 但是gcc里面默认环境可不知道jni.h是什么东西，jni.h在jdk的$JAVA_HOME/include或者$JAVA_HOME/include/linux下面，可进去查看一下~<br />4 接下来就是根据HelloNative.h中声明的方法写C语言的实现，注意，自动生成的那个函数名字很长，并且 开头的&nbsp; Java是大写的，大小写很致命，（最后我的程序在动态库已经加载好的情况下报错：java.lang.UnsatisfiedLinkError： HelloNative.greeting()V,就是因为c语言中的函数名字大小写写错，奇怪！编译不报错.....）<br />5 linux下编译生成动态库，注意不同环境的不一样~<br /><strong><span style="color: #0000ff;font-size:14px;">gcc -fPIC -I jdk/include -I jdk/include/linux -shared -o libHelloNative.so HelloNative.c</span></strong><br />&nbsp; 在这里，我犯的错：</p><p><span style="color: #ff0000;">a，不理解 -I jdk -I 是include，显示指定库的库的地址，自然后面的jdk是要用你的设计地址替换的<br />b， 着急的去网上搜索问题，没有注意的在linux下，动态链接库的名字 必须是 lib****.so，必须以lib开头！<br /></span>6 编译生成了 libHelloNative.h之后，接下写一个test类，如 HelloNativeTest，<br />当然要调用System.loadLibrary(&quot;HelloNative&quot;)；<span style="color: #ff0000;">注意此时不要lib，也不要.so!;</span><br />调用执行 HelloNative.greeting();这个时候错误又来了：<br />java.lang.UnsatisfiedLinkError: no HelloNative in java.library.path。这个错误很经典，原因：是java找不到库路径~：<br />显然： libHelloNative.so放在当前路径 &quot;.&quot;，<strong><span style="color: #ff0000;">只linux执行的时候却不知道在当前路径找。 linux很“傻”很“复杂”~<br /></span></strong>a. linux下面java.library.path 和环境变脸 jdk/bin的那个个PATH不是一回事情，有另外一个默认变量 LD_LIBRARY_PATH来保存他的信息。而windows下，首先java会找当前目录，其次，它会去环境变量的地址找！<br />b。 由于linux的路径特殊，所以，解决方法 1-可以调用sysout(<span style="color: #ff0000;">System.getProperty</span>(&quot;java.library.path&quot;));来查看！ 然后把 libXXXX.so拷贝到那里面的目录下去<br />2 设置环境变量 export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH ,但是设置到哪里呢？ /etc/profile ? or /root/.bashrc 不知道...忘记了linux的加载顺序了~<br />3 可以单次执行时候指定library位置：<br />&nbsp; java -Djava.library.path=. HelloNativeTest<br />总结犯错：1不知道gcc编译时候指定库 2 不了解java.libray.path的特点，特别是砸linux下 3 c语言实现函数的时候拼写错误 4 排除问题不够理性，系统化，出现了烦躁情绪，导致效率低。 时刻明白，机器只是做你指定的事情，总是你自己出错了~~~<br />附：gcc 参数解释(转载）：<br />&nbsp;&nbsp; 最主要的是GCC命令行的一个选项:<br />-shared 该选项指定生成动态连接库（让连接器生成T类型的导出符号表，有时候也生成弱连接W类型的导出符号），不用该标志外部程序无法连接。相当于一个可执行文件<br />l -fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。<br />l -L.：表示要连接的库在当前目录中<br />l -ltest：编译器查找动态连接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上.so来确定库的名称<br />l LD_LIBRARY_PATH：这个环境变量指示动态连接器可以装载动态库的路径。<br />l 当然如果有root权限的话，可以修改/etc/ld.so.conf文件，然后调用 /sbin/ldconfig来达到同样的目的，不过如果没有root权限，那么只能采用输出LD_LIBRARY_PATH的方法了。<br />4、注意<br />调用动态库的时候有几个问题会经常碰到，有时，明明已经将库的头文件所在目录 通过 “-I” include进来了，库所在文件通过 “-L”参数引导，并指定了“-l”的库名，但通过ldd命令察看时，就是死活找不到你指定链接的so文件，这时你要作的就是通过修改LD_LIBRARY_PATH或者/etc/ld.so.conf文件来指定动态库的目录。通常这样做就可以解决库无法链接的问题了。<br />文章来自: 好喜爱学习网(http://www.haoxiai.net) 网址：http://www.haoxiai.net/caozuoxitong/linux/5227.html</p>